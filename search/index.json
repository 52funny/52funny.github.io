[{"content":"分享一些查常用的 API 接口信息\nBilibili 获取 ip GET: http://api.bilibili.com/x/web-interface/zone\n  返回类型 json\n  返回值\n  { \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;ttl\u0026quot;: 1, \u0026quot;data\u0026quot;: { \u0026quot;addr\u0026quot;: \u0026quot;120.243.220.168\u0026quot;, \u0026quot;country\u0026quot;: \u0026quot;中国\u0026quot;, \u0026quot;province\u0026quot;: \u0026quot;安徽\u0026quot;, \u0026quot;city\u0026quot;: \u0026quot;宣城\u0026quot;, \u0026quot;isp\u0026quot;: \u0026quot;移动\u0026quot;, \u0026quot;latitude\u0026quot;: 30.941999, \u0026quot;longitude\u0026quot;: 118.746819, \u0026quot;zone_id\u0026quot;: 4407456, \u0026quot;country_code\u0026quot;: 86 } }  返回值data.addr就是 ip 信息\n","date":"2020-06-19","permalink":"https://52funny.github.io/posts/014/","tags":["API"],"title":"API接口"},{"content":"最近在家实在无聊,然后打开了教务系统然后对他的登陆系统分析了一下发现大概是以下步骤\n获取 Cookie 首先我们可以访问教务系统的网址,然后获取 Cookie 的JSESSIONID值将其进行保存.\n加密账号密码信息 这时我们来分析一下网页 HTML 文件\n\u0026lt;td colspan=\u0026quot;2\u0026quot; height=\u0026quot;26px\u0026quot; align=\u0026quot;center\u0026quot; valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;login\u0026quot; name=\u0026quot;login\u0026quot; class=\u0026quot;login\u0026quot; onclick=\u0026quot;doLogon();\u0026quot; value=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; id=\u0026quot;reset\u0026quot; name=\u0026quot;reset\u0026quot; class=\u0026quot;reset\u0026quot; onclick=\u0026quot;doReset();\u0026quot; value=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;a href=\u0026quot;javascript:void(0);\u0026quot; onclick=\u0026quot;MobileReset();\u0026quot; style=\u0026quot;padding-left: 10px;\u0026quot;\u0026gt;忘记密码\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt;  我们可以看见当按了登陆按钮时,这是我们执行的是一个doLogin的 JavaScript 的代码\n我们继续找到这个 doLogin 的函数,发现他在这个 JavaScript 文件里\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/suzxyjw/frame/Login.js?version=20181119\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  继续找到这个文件里的doLogin 函数\nfunction doLogon() { // 输入信息验证 if (!validate()) { return false } // 验证码正确性验证 var username = j$('#yhmc').val() var password = j$('#yhmm').val() var randnumber = j$('#randnumber').val() var passwordPolicy = kutil.isPasswordPolicy(username, password) var url = _webRootPath + 'cas/logon.action' var txt_mm_expression = document.getElementById('txt_mm_expression').value var txt_mm_length = document.getElementById('txt_mm_length').value var txt_mm_userzh = document.getElementById('txt_mm_userzh').value password = hex_md5(hex_md5(password) + hex_md5(randnumber.toLowerCase())) /** var params = { \u0026quot;yhmc\u0026quot; : username, \u0026quot;yhmm\u0026quot; : password, \u0026quot;randnumber\u0026quot;: randnumber, \u0026quot;isPasswordPolicy\u0026quot; : passwordPolicy }; */ var p_username = '_u' + randnumber var p_password = '_p' + randnumber username = base64encode(username + ';;' + _sessionid) var params = p_username + '=' + username + '\u0026amp;' + p_password + '=' + password + '\u0026amp;randnumber=' + randnumber + '\u0026amp;isPasswordPolicy=' + passwordPolicy + '\u0026amp;txt_mm_expression=' + txt_mm_expression + '\u0026amp;txt_mm_length=' + txt_mm_length + '\u0026amp;txt_mm_userzh=' + txt_mm_userzh //alert(\u0026quot;params=\u0026quot;+params); params = getEncParams(params) //alert(\u0026quot;encparams=\u0026quot;+params); doPreLogon() kutil.doAjax(url, params, doPostLogon) function doPreLogon() { j$('#msg').html('正在登录......') j$('#login').attr('disabled', true) j$('#reset').attr('disabled', true) } function doPostLogon(response) { var data = JSON.parse(response) var status = data.status var message = data.message if ('200' == status) { var result = data.result window.document.location.href = result } else { reloadScript('kingo_encypt', _webRootPath + 'custom/js/SetKingoEncypt.jsp') if ('407' == status) { alert(message) showMessage('') } else { showMessage(message) } j$('#login').attr('disabled', false) j$('#reset').attr('disabled', false) refreshImg() if ('401' == status) { j$('#randnumber').val('') j$('#randnumber').focus() } else { j$('#yhmc').val('') j$('#yhmm').val('') j$('#randnumber').val('') j$('#yhmc').focus() } } } }  我们继续来分析\n首先username, password, randnumber 就是你的账号密码和验证码\n其次passwordPolicy 是一个函数的返回值我没有找到这个函数但是我用了一种方法就是在控制台来输出函数的返回值.\n我随便试了一个账户和密码\n然后他的返回值是0\n然后输入了正确的账号密码\n然后他的返回值是1\n所以我们只需要知道passwordPolicy的值是1\n接着分析 txt_mm_expression txt_mm_length  txt_mm_userzh 这三个变量是通过获取元素的值\nvar txt_mm_expression = document.getElementById('txt_mm_expression').value var txt_mm_length = document.getElementById('txt_mm_length').value var txt_mm_userzh = document.getElementById('txt_mm_userzh').value  然后我就在之前的 HTML 文件中找到声明这三个变量的 JavaScrpt 代码\nfunction checkpwd(oInput) { var pwd = oInput.value var result = 0 for (var i = 0, len = pwd.length; i \u0026lt; len; ++i) { result |= charType(pwd.charCodeAt(i)) } document.getElementById('txt_mm_expression').value = result //密码规则 document.getElementById('txt_mm_length').value = pwd.length //密码长度 var userzh = document.getElementById('yhmc').value //取账号 var inuserzh = '0' if (pwd.toLowerCase().trim().indexOf(userzh.toLowerCase().trim()) \u0026gt; -1) { inuserzh = '1' } document.getElementById('txt_mm_userzh').value = inuserzh //判断密码是否包含账号 } function charType(num) { if (num \u0026gt;= 48 \u0026amp;\u0026amp; num \u0026lt;= 57) { return 8 } if (num \u0026gt;= 97 \u0026amp;\u0026amp; num \u0026lt;= 122) { return 4 } if (num \u0026gt;= 65 \u0026amp;\u0026amp; num \u0026lt;= 90) { return 2 } return 1 }  通过代码分析可知txt_mm_expression 是一个密码的复杂度遵从以下规则\n   数字 大写字母 小写字母 其他符号     8 2 4 1    比如我的密码是以下几种情况的话, 返回值分别如下\n123 -\u0026gt; 8 123A -\u0026gt; 10 123Aa -\u0026gt; 14 123Aa# -\u0026gt; 15  txt_mm_length就很简单了, 他就是密码的长度.\ntxt_mm_userzh 从他的注释来看就是判断密码是否包含账号.\n接着我们来分析doLogin函数\npassword = hex_md5(hex_md5(password) + hex_md5(randnumber.toLowerCase()))  hex_md5 函数就是把字符串变成 md5 值\n然后他将这些变量进行base64encode 最后得到一个params 变量\nvar p_username = '_u' + randnumber var p_password = '_p' + randnumber username = base64encode(username + ';;' + _sessionid) var params = p_username + '=' + username + '\u0026amp;' + p_password + '=' + password + '\u0026amp;randnumber=' + randnumber + '\u0026amp;isPasswordPolicy=' + passwordPolicy + '\u0026amp;txt_mm_expression=' + txt_mm_expression + '\u0026amp;txt_mm_length=' + txt_mm_length + '\u0026amp;txt_mm_userzh=' + txt_mm_userzh  然后将params 用getEncParams 函数加密\nparams = getEncParams(params)  然后发现他在另一个 JavaScript 文件里\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/suzxyjw/custom/js/SetKingoEncypt.jsp?t=4901586828474712746\u0026quot; id=\u0026quot;kingo_encypt\u0026quot; \u0026gt;\u0026lt;/script\u0026gt;  但是这个 JavaScript 文件后面的链接 t 后面的参数是 刷新一次网页就会变的,所以我们要用正则表达式进行提取 /suzxyjw/custom/js/SetKingoEncypt.jsp\\?t=[0-9]+\n然后打开这个 JavaScript 脚本\nvar _deskey = '6061586830242491265' var _nowtime = '2020-04-14 10:10:42' document.write( \u0026quot;\u0026lt;script type='text/javascript' src='http://211.86.128.194:80/suzxyjw/custom/js/base64.js'\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; ) document.write( \u0026quot;\u0026lt;script type='text/javascript' src='http://211.86.128.194:80/suzxyjw/custom/js/md5.js'\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; ) document.write( \u0026quot;\u0026lt;script type='text/javascript' src='http://211.86.128.194:80/suzxyjw/custom/js/jkingo.des.js'\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; ) function b64_encode(data) { return base64encode(utf16to8(data)) } function b64_decode(data) { return utf8to16(base64decode(data)) } function md5(data) { return hex_md5(data) } function des_encode(data) { return strEnc(data, _deskey, null, null) } function des_decode(data) { return strDec(data, _deskey, null, null) } function getEncParams(params) { var timestamp = _nowtime var token = md5(md5(params) + md5(timestamp)) var _params = b64_encode(des_encode(params)) _params = 'params=' + _params + '\u0026amp;token=' + token + '\u0026amp;timestamp=' + timestamp return _params } function reloadScript00(id, jsfile) { jsfile = jsfile + '?random=' + Math.random() if (id == 'kingo_encypt') document.getElementById('kingo_encypt').src = jsfile } function reloadScript(id, jsfile) { var oldS = document.getElementById(id) if (oldS) oldS.parentNode.removeChild(oldS) var t = document.createElement('script') if (new String(jsfile).indexOf('?') \u0026gt; -1) { jsfile = jsfile + '\u0026amp;random=' + Math.random() } else { jsfile = jsfile + '?random=' + Math.random() } t.src = jsfile t.type = 'text/javascript' t.id = id document.getElementsByTagName('head')[0].appendChild(t) } var G_LOGIN_ID = 'kingo.guest'  发现getEncParams 这个函数里面有一个函数des_encode\n这个des_encode 里面有一个函数 strEnc(data, _deskey, null, null)\nstrEnc 接受四个参数 data, firstKey, secondKey, thirdKey.\n jkingo.des.js 链接我将放置文章末尾\n 这里有个坑就是我们访问这个SetKingoEncypt.jsp 链接是 我们必须要携带 Cookie 访问, 而且每次访问出来的_deskey, _nowtime 都是不一样的, 这里我们还是要进行字符串的提取可以用正则也可以用其他的.\n提交登陆信息 最后通过 Post 请求发送数据表单\n'params=' + _params + '\u0026amp;token=' + token + '\u0026amp;timestamp=' + timestamp  表单总共有三个数据 params, token, timestamp\n最后发送 POST 请求后可以得到如下的 JSON 数据\n{ \u0026quot;message\u0026quot;: \u0026quot;操作成功!\u0026quot;, \u0026quot;result\u0026quot;: \u0026quot;/suzxyjw/MainFrm.html?random=0.14040851742858051\u0026quot;, \u0026quot;status\u0026quot;: \u0026quot;200\u0026quot; }  最后就可以用 CookIe 进行其他的操作了.\n jkingo.des.js\n演示代码(仅供参考)\n","date":"2020-04-14","permalink":"https://52funny.github.io/posts/013/","tags":["Go"],"title":"KINGOSOFT模拟登陆"},{"content":"超星学习通签到工具  这是我参考一个大佬的python 脚本写的 go 语言版本 首先感谢大佬\n config.json 使用说明 在项目的根目录里有一个config.json的文件,这个就是配置文件了\n{ \u0026quot;username\u0026quot;: \u0026quot;账号\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;密码\u0026quot;, \u0026quot;time\u0026quot;: 10, \u0026quot;blockclasslist\u0026quot;: [\u0026quot;《理想国》导读\u0026quot;, \u0026quot;[考试]马克思主义基本原理概论\u0026quot;, \u0026quot;入馆教育\u0026quot;], \u0026quot;start\u0026quot;: \u0026quot;08:00:00\u0026quot;, \u0026quot;end\u0026quot;: \u0026quot;18:00:00\u0026quot;, \u0026quot;logfile\u0026quot;: \u0026quot;./log.log\u0026quot;, \u0026quot;SCKEY\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;model\u0026quot;: true, \u0026quot;advance\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;大闹天宫\u0026quot;, \u0026quot;address\u0026quot;: \u0026quot;安徽\u0026quot;, \u0026quot;latitude\u0026quot;: \u0026quot;31.3300000000\u0026quot;, \u0026quot;longitude\u0026quot;: \u0026quot;118.3800000000\u0026quot;, \u0026quot;picpath\u0026quot;: \u0026quot;./icon.png\u0026quot; } }  username 账户 (改成你的账户)\npassword 密码 (改成你的密码)\ntime 轮询查找科目的时间\nblockclasslist 课程黑名单, 在此名单里的项目将不会在轮询查找的名单里\nstart 每天开始的时间\nend 每天结束的时间\nlogfile 日志文件地址\nSCKEY server 酱的 sckey 留空表示不发送消息到微信\nmodel 模式(false: 普通模式进行签到, true: 高级模式进行签到) advance 下面的子项就是高级模式的配置信息\nadvance.name 签到时的名字\nadvance.address 签到时的地址\nadvance.latitude 纬度\nadvance.longitude 经度\nadvance.picpath 默认上传图片的地址\n将以上信息修改之后\n windows  双击启动   linux  一般 ./chaoxingsign 后台运行 ./chaoxingsign \u0026gt; test.log \u0026amp; 1    运行效果 Tips server 酱使用方法\n下载地址 https://github.com/52funny/chaoxingsign/releases\n","date":"2020-03-25","permalink":"https://52funny.github.io/posts/012/","tags":["Go"],"title":"超星学习通签到"},{"content":"tips  解决Host '192.168.1.75' is not allowed to connect to this MySQL server  use mysql; update user set host='%' where user='root'; FLUSH PRIVILEGES;  %是通配符 show variables like 'gen%'  +----------------------------------+---------------------------+ | Variable_name | Value | +----------------------------------+---------------------------+ | general_log | OFF | | general_log_file | /var/lib/mysql/debian.log | | generated_random_password_length | 20 | +----------------------------------+---------------------------+  创建数据库,并使用数据库 create database soft; use soft;  创建表 create table stu( sno varchar(20), sname varchar(20), ssex char(4), sage smallint );  show tables; 使用前需选中\n+---------------+ | Tables_in_stu | +---------------+ | stu | +---------------+  详细的查询表 desc stu; show create table stu;  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | ssex | char(4) | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+  修改表的属性  添加字段 alter table stu add sco int after ssex  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | ssex | varchar(4) | YES | | NULL | | | sco | int | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   修改字段 alter table stu modify sco float;  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | ssex | varchar(4) | YES | | NULL | | | sco | float | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   重命名字段 alter table stu change ssex sex varchar(4);  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sco | float | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   删除字段 alter table stu drop sco;  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   对表重命名 alter table stu rename stuinfo;  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+  复制表  复制表的结构和索引 create table if not exists stu like stuinfo;  +---------------+ | Tables_in_stu | +---------------+ | stu | | stuinfo | +---------------+ mysql\u0026gt; desc stu; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   复制表中的数据 create table stunew as select sno, sname from stu;  +---------------+ | Tables_in_stu | +---------------+ | stu | | stuinfo | | stunew | +---------------+ mysql\u0026gt; desc stunew; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+  删除表  drop table if exists stunew;  +---------------+ | Tables_in_stu | +---------------+ | stu | | stuinfo | +---------------+  设置默认字段  设置默认字段alter table stu alter sex set default '男'  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | YES | | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | 男 | | | sage | smallint | YES | | NULL | | +-------+-------------+------+-----+---------+-------+   删除默认字段 alter table stu alter sex drop default  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | NO | PRI | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sage | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+  添加主键 create table stuinfo( sno varchar(20) not null, sname varchar(20), sex varchar(4), sage varchar(4), primary key(sno) );  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | NO | PRI | NULL | | | sname | varchar(20) | YES | | NULL | | | sex | varchar(4) | YES | | NULL | | | sage | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+  添加外键  表级约束(在创建之后来修改)  on delet 和 on update 后面有很多参数可选    [on delete {cascade| restrict |set null | no action} ] [on update {cascade| restrict |set null | no action} ]  alter table sc add foreign key(sno) references stu(sno) on update restrict on delet restrict;  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | NO | PRI | NULL | | | cno | varchar(20) | NO | PRI | NULL | | | grade | int | NO | | NULL | | +-------+-------------+------+-----+---------+-------+   列级约束  在字段的后面加一个 references    create table sc ( sno varchar(20) not null references stu(sno), cno varchar(20) not null, grade int default 0, primary key(sno, cno) );  +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | sno | varchar(20) | NO | PRI | NULL | | | cno | varchar(20) | NO | PRI | NULL | | | grade | int | YES | | 0 | | +-------+-------------+------+-----+---------+-------+   完整性约束  create table sc( sno varchar(20) not null, cno varchar(20) not null, grade int not null default 0, primary key(sno, cno), constraint sc_student_fk foreign key(sno) references stu(sno) );  +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | sc | CREATE TABLE `sc` ( `sno` varchar(20) NOT NULL, `cno` varchar(20) NOT NULL, `grade` int NOT NULL DEFAULT '0', PRIMARY KEY (`sno`,`cno`), CONSTRAINT `sc_stundent_fk` FOREIGN KEY (`sno`) REFERENCES `stu` (`sno`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+  删除约束  删除外键 alter table sc drop foreign key sc_stundent_fk; 删除主键 alter table sc drop primary key; 删除非空 alter table sc modify sno varchar(20) null 删除默认值 alter table sc drop default 删除唯一约束 alter table sc modify sno varchar(20)  表的增加  insert stu values('2018110801','张三', '男', 20);  +------------+--------+------+------+ | sno | sname | ssex | sage | +------------+--------+------+------+ | 2018110801 | 张三 | 男 | 20 | +------------+--------+------+------+   insert stu(sname, sno, sage, ssex) values('李四', '2018110802', 23, '女');  +------------+--------+------+------+ | sno | sname | ssex | sage | +------------+--------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | +------------+--------+------+------+   insert stu values('2018110803', '王二麻', '男', 25), ('2018110804', '李二狗', '女', 28);  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+  表的改动  update stu set sname='张三三' where sno = 2018110801;  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+  表的删除  delete from stu; 清空表的数据,但保留数据表的结构 truncate stu; 清空表的数据,保留数据表的结构   delete，drop，truncate 都有删除表的作用，区别在于：\n1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\n2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n3、执行的速度上，drop\u0026gt;truncate\u0026gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n 表的查询  select * from stu; 查询所有信息  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+   select sno, sname from stu; 查询固定信息  +------------+-----------+ | sno | sname | +------------+-----------+ | 2018110801 | 张三 | | 2018110802 | 李四 | | 2018110803 | 王二麻 | | 2018110804 | 李二狗 | +------------+-----------+     AND OR IN NOT IN BETWEEN     与 或 在 不在 范围    用条件来查询  select * from stu where sage \u0026gt; 20 and sage \u0026lt; 25;  +------------+--------+------+------+ | sno | sname | ssex | sage | +------------+--------+------+------+ | 2018110802 | 李四 | 女 | 23 | +------------+--------+------+------+   select * from stu where sage between 20 and 25; 包括边界  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | +------------+-----------+------+------+   select * from stu where ssex in ('男');  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110803 | 王二麻 | 男 | 25 | +------------+-----------+------+------+   select * from stu where ssex not in('男');  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110802 | 李四 | 女 | 23 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+  通配符    % -     匹配任意多个字符 匹配一个任意字符     select * from stu where sno like '2018110_0_';  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+   select * from stu where sno like '201811%';  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+  对结果排序    ASC DESC     升序 降序     select * from stu order by sage asc;  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110801 | 张三 | 男 | 20 | | 2018110802 | 李四 | 女 | 23 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110804 | 李二狗 | 女 | 28 | +------------+-----------+------+------+   select * from stu order by sage desc;  +------------+-----------+------+------+ | sno | sname | ssex | sage | +------------+-----------+------+------+ | 2018110804 | 李二狗 | 女 | 28 | | 2018110803 | 王二麻 | 男 | 25 | | 2018110802 | 李四 | 女 | 23 | | 2018110801 | 张三 | 男 | 20 | +------------+-----------+------+------+  SQL 内置函数    函数名 COUNT SUM AVG MAX MIN     作用 计数 求和 求平均值 最大值 最小值     其中 COUNT 函数可用于任何数据类型(因为它只是计数)，而另 4 个函数都只能对数字类数据类型做计算。\n  select min(sage), max(sage), sum(sage), avg(sage) from stu;  +-----------+-----------+-----------+-----------+ | min(sage) | max(sage) | sum(sage) | avg(sage) | +-----------+-----------+-----------+-----------+ | 20 | 28 | 96 | 24.0000 | +-----------+-----------+-----------+-----------+   select min(sage) as min, max(sage) as max, avg(sage) as avg, sum(sage) as sum from stu;  +------+------+---------+------+ | min | max | avg | sum | +------+------+---------+------+ | 20 | 28 | 24.0000 | 96 | +------+------+---------+------+  子查询  select * from sc where sno in (select sno from stu where sname like '_二麻');  +------------+--------------+-------+ | sno | cno | grade | +------------+--------------+-------+ | 2018110803 | 大学物理 | 28 | | 2018110803 | 大学英语 | 48 | +------------+--------------+-------+   子查询还可以扩展到 3 层、4 层或更多层。\n 连接查询  select * from stu, sc; 两张表笛卡尔积  +------------+-----------+------+------+------------+--------------+-------+ | sno | sname | ssex | sage | sno | cno | grade | +------------+-----------+------+------+------------+--------------+-------+ | 2018110804 | 李二狗 | 女 | 28 | 2018110801 | 大学物理 | 97 | | 2018110803 | 王二麻 | 男 | 25 | 2018110801 | 大学物理 | 97 | | 2018110802 | 李四 | 女 | 23 | 2018110801 | 大学物理 | 97 | | 2018110801 | 张三 | 男 | 20 | 2018110801 | 大学物理 | 97 | | 2018110804 | 李二狗 | 女 | 28 | 2018110802 | 大学物理 | 68 | | 2018110803 | 王二麻 | 男 | 25 | 2018110802 | 大学物理 | 68 | | 2018110802 | 李四 | 女 | 23 | 2018110802 | 大学物理 | 68 | | 2018110801 | 张三 | 男 | 20 | 2018110802 | 大学物理 | 68 | | 2018110804 | 李二狗 | 女 | 28 | 2018110803 | 大学物理 | 28 | | 2018110803 | 王二麻 | 男 | 25 | 2018110803 | 大学物理 | 28 | | 2018110802 | 李四 | 女 | 23 | 2018110803 | 大学物理 | 28 | | 2018110801 | 张三 | 男 | 20 | 2018110803 | 大学物理 | 28 | | 2018110804 | 李二狗 | 女 | 28 | 2018110804 | 大学物理 | 58 | | 2018110803 | 王二麻 | 男 | 25 | 2018110804 | 大学物理 | 58 | | 2018110802 | 李四 | 女 | 23 | 2018110804 | 大学物理 | 58 | | 2018110801 | 张三 | 男 | 20 | 2018110804 | 大学物理 | 58 | | 2018110804 | 李二狗 | 女 | 28 | 2018110801 | 大学英语 | 91 | | 2018110803 | 王二麻 | 男 | 25 | 2018110801 | 大学英语 | 91 | | 2018110802 | 李四 | 女 | 23 | 2018110801 | 大学英语 | 91 | | 2018110801 | 张三 | 男 | 20 | 2018110801 | 大学英语 | 91 | | 2018110804 | 李二狗 | 女 | 28 | 2018110802 | 大学英语 | 98 | | 2018110803 | 王二麻 | 男 | 25 | 2018110802 | 大学英语 | 98 | | 2018110802 | 李四 | 女 | 23 | 2018110802 | 大学英语 | 98 | | 2018110801 | 张三 | 男 | 20 | 2018110802 | 大学英语 | 98 | | 2018110804 | 李二狗 | 女 | 28 | 2018110803 | 大学英语 | 48 | | 2018110803 | 王二麻 | 男 | 25 | 2018110803 | 大学英语 | 48 | | 2018110802 | 李四 | 女 | 23 | 2018110803 | 大学英语 | 48 | | 2018110801 | 张三 | 男 | 20 | 2018110803 | 大学英语 | 48 | | 2018110804 | 李二狗 | 女 | 28 | 2018110804 | 大学英语 | 18 | | 2018110803 | 王二麻 | 男 | 25 | 2018110804 | 大学英语 | 18 | | 2018110802 | 李四 | 女 | 23 | 2018110804 | 大学英语 | 18 | | 2018110801 | 张三 | 男 | 20 | 2018110804 | 大学英语 | 18 | +------------+-----------+------+------+------------+--------------+-------+   select * from stu, sc where stu.sno = sc.sno;  +------------+-----------+------+------+------------+--------------+-------+ | sno | sname | ssex | sage | sno | cno | grade | +------------+-----------+------+------+------------+--------------+-------+ | 2018110801 | 张三 | 男 | 20 | 2018110801 | 大学物理 | 97 | | 2018110802 | 李四 | 女 | 23 | 2018110802 | 大学物理 | 68 | | 2018110803 | 王二麻 | 男 | 25 | 2018110803 | 大学物理 | 28 | | 2018110804 | 李二狗 | 女 | 28 | 2018110804 | 大学物理 | 58 | | 2018110801 | 张三 | 男 | 20 | 2018110801 | 大学英语 | 91 | | 2018110802 | 李四 | 女 | 23 | 2018110802 | 大学英语 | 98 | | 2018110803 | 王二麻 | 男 | 25 | 2018110803 | 大学英语 | 48 | | 2018110804 | 李二狗 | 女 | 28 | 2018110804 | 大学英语 | 18 | +------------+-----------+------+------+------------+--------------+-------+   select * from stu join sc on stu.sno = sc.sno; 使用 join to 达到上一步一样的步骤  +------------+-----------+------+------+------------+--------------+-------+ | sno | sname | ssex | sage | sno | cno | grade | +-------男 | 20 | 2018110801 | 大学英语 | 91 | | 2018110802 | 李四 | 女 | 23 | 2018110802 | 大学英语 | 98 | | 2018110803 | 王二麻 | 男 | 25 | 2018110803 | 大学英语 | 48 | | 2018110804 | 李二狗 | 女 | 28 | 2018110804 | 大学英语 | 18 | +------------+-----------+------+------+------------+--------------+-------+  创建索引 普通索引  普通索引是最基本的索引, 没有任何限制.他有以下几种方式创建\n  create index indexname on tablename(username(length)); 基本方式 alter table tablename add index indexname(columName); 添加索引 create table tablename( id varchar(20) primary key, name varchar(10) not null, index index_name (name(10)) ); 创建表时直接创建  删除索引 drop index [indexname] on mytable; alter table tablename drop index c\n唯一索引  它与普通索引差不多,只不过唯一索引必须值唯一,但允许有空值,如果是组合索引,则值必须唯一.创建方式和上面的差不多\n  create unique index indexname on mytable(username(length)); alter table tablename add unique index [indexname] (username(length)) create table tablename( id varchar(20) primary key, name varchar(10) not null, unique index index_name (name(10)) );  显示索引 show index from tablename\n视图 创建视图  create view view_stu as select * from stu;  删除视图  drop view if exists view_stu;  视图定以  desc view_stu  修改视图  create or replace view view_stu as select sno, sname from stu; alter view view_stu as select sno, sname from stu; ","date":"2020-03-25","permalink":"https://52funny.github.io/posts/011/","tags":["mysql"],"title":"数据库基础"},{"content":" Rocket.Chat docs\n 这次使用这个 Rocket.Chat 是为了填补上次的 Caddy 的坑,上次的 Caddy 并没有展现 Caddy 的魅力,这次我用 Caddy 的反向代理来部署 Rocket.Chat 这个服务.\nRocket.Chat 是一种类似 Slack 的开源聊天软件.\nRocket.Chat 的特性  群组聊天 直接通信 私聊群 桌面通知 媒体嵌入 链接预览 文件上传 语音/视频聊天 截图 支持你目前使用的任何平台  我将用 Caddy 的反向代理和自动签发 https 证书来搭建 Rocket.Chatl, 我将在 Ununtu18.04(LTS)上来搭建\n部署环境  一台 Ubuntu18.04 (LTS)的服务器 域名 (非必须,我将演示非域名和域名的不同环境)  不使用 Caddy 反向代理 连接 vps, 然后更新操作系统\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y  用 snap 安装 Rocket.Chat\nsudo snap install rocketchat-server  然后你就安装完毕了\n然后在浏览器里输入你的ip:3000就可以访问你的 Rocket.Chat\n使用 Caddy 反向代理 安装 Caddy 可以参考之前的文档CaddyServer 搭建 web 服务器\n编辑 Caddyfile 文件\nsudo vim /etc/caddy/Caddyfile  输入以下内容\nhttp://:80 { reverse_proxy * 127.0.0.1:3000 encode zstd gzip }  然后就可以通过域名访问了\n用域名访问 首先你的去域名服务商,添加一个 A 记录指向你的服务器 ip\n编辑 Caddyfile 文件\nsudo vim /etc/caddy/Caddyfile  输入以下内容\nyourdomain { tls youremail reverse_proxy * 127.0.0.1:3000 encode zstd gzip }  只需要将 yourdomain 改成你的解析的域名, youremail 改成你的邮箱\nFor Example\nchat.redwolf233.top { tls 1374034750@qq.com reverse_proxy * 127.0.0.1:3000 encode zstd gzip }  然后你就可以访问你的域名来进行操作了,下面给几张 Photos ","date":"2020-03-02","permalink":"https://52funny.github.io/posts/010/","tags":["Linux","Canddy"],"title":"利用Caddy方向代理Rocket.Chat"},{"content":" CaddyServer 官方文档\n CaddyServer 是基于 go 语言写的一款搭建 web 前端的软件,之前我搭建网站都是用的宝塔面板,用起来超级好用但是就是搭建时间比较长,而这款软件 Caddy 搭建网站基本上就是 2-3 分钟就可以搭建一个网站.今天我就演示一下如何用这个 CaddyServer 来搭建一个 Ariang 的面板\nPS:我用的是 CaddyServer 的 v2 版本.v2 版本和 v1 的版本语法不兼容\nCaddy 安装 首先我们得下载 Caddy 的执行文件,然后放入到/usr/bin/目录下\nsudo wget -O /usr/bin/caddy https://github.com/caddyserver/caddy/releases/download/v2.0.0-beta.15/caddy2_beta15_linux_amd64 \u0026amp;\u0026amp; chmod +x /usr/bin/caddy  然后可以输入一下caddy version 来检测 caddy 命令是否在你的$PATH 下\n然后创建一个 caddy 的组\ngroupadd --system caddy  然后创建一个用户 caddy,和具有可写的目录\nuseradd --system \\ --gid caddy \\ --create-home \\ --home-dir /var/lib/caddy \\ --shell /usr/sbin/nologin \\ --comment \u0026quot;Caddy web server\u0026quot; \\ caddy  然后我们可以下载一个官方给的caddy.service的文件放到/etc/systemd/system/caddy.service\nsudo wget -O /etc/systemd/system/caddy.service https://raw.githubusercontent.com/caddyserver/dist/master/init/caddy.service  之后我们重启 systemctl,和启动 caddy\nsudo systemctl daemon-reload sudo systemctl enable caddy sudo systemctl start caddy  然后我们可以验证一下是否启动,如果出现(active) running就说明好了\nsudo systemctl status caddy  Caddyfile 编写 Caddy 可以让我们用 Caddyfile 来启动 caddy 接下来我将用 Caddyfile 来写一个 AriaNg 的网站.\n首先我们的去下载一个 AriaNg 的代码放入到/var/www/ariang目录下并且解压缩\nsudo wget -O /var/www/ariang/ariang.zip https://github.com/mayswind/AriaNg/releases/download/1.1.4/AriaNg-1.1.4.zip \u0026amp;\u0026amp; sudo unzip -o /var/www/ariang/ariang.zip -d /var/www/ariang/ \u0026amp;\u0026amp; sudo rm /var/www/ariang/ariang.zip  然后我们去/etc/caddy/目录新建一个文件Caddyfile然后开始写配置文件\ncd /etc/caddy/ \u0026amp;\u0026amp; sudo touch Caddyfile  然后用 vim 来写一段配置文件到 Caddyfile\nvim Caddyfile  然后把这一段代码粘贴进去\nhttp://:6088 { file_server { root /var/www/ariang } encode zstd gzip }  最后输入以下命令,如果没报错就可以了\ncaddy reload  ps 6088 是端口,可以自行修改\n之后我们上浏览器输入http://127.0.0.1:6088 or http://localhost:6088就可以看到网站了\n当然 CaddyServer 还有很多功能\n 虚拟主机 反向代理 静态文件分发 负载均衡 FastCGI 支持 MarkDown 渲染 Gzip 压缩 URL 重写 重定向 文件浏览服务  本次就用了 CaddyServer 的虚拟主机搭建了一个小的网站,CaddyServer 还有很多好玩的等着大家去探索.\n此处贴一张网站的 Photo ","date":"2020-02-29","permalink":"https://52funny.github.io/posts/009/","tags":["Linux","Canddy"],"title":"CaddyServer搭建web服务器"},{"content":"实现一个算法，确定一个字符串 s 的所有字符是否全都不同。\n示例 1 输入: s = \u0026quot;leetcode\u0026quot; 输出: false  示例 2 输入: s = \u0026quot;abc\u0026quot; 输出: true  首先我们可能会想到用两层循环来写但是那可能会超时，但是我们有更聪明的写法，就是声明一个数组来存这个出现了多少次，当这个出现的次数大于 1 的时候就说明不是一个正确的案例\n下面给出 Go 代码\nfunc isUnique(astr string) bool { var chars [256]int for _, as := range astr { chars[byte(as)]++ if chars[byte(as)] \u0026gt; 1 { return false } } return true }  还有一种就是位运算利用一个 int（可以开 int64 位的变量） 假如是 mark 变量（000000000\u0026hellip;）利用每一位上的二进制来模拟字符是否出现过，如果没出现过，那么我们将1 \u0026lt;\u0026lt;( 字符与'a'的差值) | mark赋值给 mark，来表示这个字符出现过。这样的做法会更省空间，就不用开一个数组来存字符出现的个数\n下面给出 Go 的代码\nfunc isUnique(astr string) bool { mark := 0 for _, as := range astr { if 1\u0026lt;\u0026lt;(as-'a')\u0026amp;mark == 0 { mark |= 1 \u0026lt;\u0026lt; (as - 'a') } else { return false } } return true }  当然也可以用 C/C++来写，这里我就不演示了。\n","date":"2020-02-28","permalink":"https://52funny.github.io/posts/008/","tags":["算法","Leetcode"],"title":"判断字符是否唯一"},{"content":"docker 安装 通过命令安装\nwget -qO- https://get.docker.com/ | sh\n安装完毕后将普通用户加入到 docker 用户组（为的是让 docker 能让普通用户使用）\nsudo gpasswd -a ${USER} docker\n然后重启 docker\nsudo systemctl restart docker\n然后刷新用户组\nnewgrp docker\n","date":"2019-12-30","permalink":"https://52funny.github.io/posts/007/","tags":["Linux","Docker"],"title":"Docker基础"},{"content":" 清华大学严蔚敏《数据结构》\n清华大学李春葆《数据结构教程》\n 快速排序 数据结构课已经临近尾声，今天老师还给我们讲了一点排序，但是我觉得排序里面在算法里面最好用的还是快速排序，C++ algorithm头文件里的sort(_RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp)函数就是快速排序算法。\n快速排序的基本思想就是在待排序的 n 个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入适当位置后，数据序列被此元素分成两部分。所有关键字比该元素关键字小的元素放置在前一部分，所有比它大的元素放置在后一部分，并把该元素排在这两部分的中间，这个过程称为一趟快速排序，及一趟划分。\n之后对产生的两个部分分别重复上述过程，直至每部分内只有一个元素或为空为止。简而言之，每趟使表的第一个元素放入适当位置，将表一分为二，对子表按照递归方式继续这种划分，直至划分的子表的长为 1 或 0。\n我们来举个栗子\n首先给个序列\n6 8 7 9 0 1 3 2 4 5 基准为 6\n5 4 2 3 0 1 6 9 7 8 一次划分\n5 4 2 3 0 1 进行划分\n1 4 2 3 0 5 6 9 7 8 二次划分\n1 4 2 3 0 进行划分\n0 1 2 3 4 5 6 9 7 8 三次划分\n2 3 4 进行划分\n0 1 2 3 4 5 6 9 7 8 四次划分\n3 4 进行划分\n0 1 2 3 4 5 6 9 7 8 五次划分\n9 8 7 进行划分\n0 1 2 3 4 5 6 8 7 9  六次划分\n8 7 划分\n0 1 2 3 4 5 6 7 8 9 七次划分\n所以快速排序还是很是实用的\nC++代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int Partition(int a[], int l, int r) { int temp = a[l]; int i = l, j = r; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt;= temp) j--; a[i] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt;= temp) i++; a[j] = a[i]; } a[i] = temp; return i; } void QuickSort(int a[], int l, int r) { if (l \u0026lt; r) { int i = Partition(a, l, r); QuickSort(a, l, i - 1); //左区间划分 QuickSort(a, i + 1, r); //右区间划分 } } int main() { int n; cin \u0026gt;\u0026gt; n; int a[100]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } QuickSort(a, 0, n - 1); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; ' '; }  我们也可以把递归函数 QuickSort 函数写入划分函数 Partition\n将递归写入划分\nC++代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int Partition(int a[], int l, int r) { int temp = a[l]; int i = l, j = r; if (l \u0026lt; r) { while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt;= temp) j--; a[i] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt;= temp) i++; a[j] = a[i]; } a[i] = temp; Partition(a, l, i - 1);\t//左区间 Partition(a, i + 1, r);\t//右区间 } } int main() { int n; cin \u0026gt;\u0026gt; n; int a[100]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } Partition(a, 0, n - 1); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; ' '; } ","date":"2019-12-19","permalink":"https://52funny.github.io/posts/006/","tags":["算法"],"title":"排序算法"},{"content":"说实话这次的题目比上次的简单，难度不算很大。比较适中，没有什么难度。\n熊文静很怕冷 这题很简单，就是一个简单的循环，我做的时候一不小心忘记了当 n = 1 的时候要特判一下，所以直接 给出代码\nC 语言\n#include \u0026lt;stdio.h\u0026gt; int maxn = -0x3f3f3f; int main() { int n; int a[10005]; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); int cot = 1; if (n == 1) { printf(\u0026quot;%d\u0026quot;, n); return 0; } for (int i = 1; i \u0026lt; n; i++) { int t = a[i - 1]; if (a[i] \u0026gt; t) cot++; else { if (cot \u0026gt; maxn) maxn = cot; cot = 1; } } printf(\u0026quot;%d\u0026quot;, maxn); }  魔法火柴 这题是一题很老的题目了，暴力枚举就可以出答案。\nC 代码\n#include \u0026lt;stdio.h\u0026gt; int a[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; int getall(int i) { if (i == 0) return a[i]; int sum = 0; while (i) { sum += a[i % 10]; i /= 10; } return sum; } int main() { int n; while (~scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)) { n -= 4; int ans = 0; for (int i = 0; i \u0026lt;= 1000; i++) for (int j = i; j \u0026lt;= 1000; j++) if (getall(i) + getall(j) + getall(i + j) == n) if (i == j) ans += 1; else ans += 2; printf(\u0026quot;%d\\n\u0026quot;, ans); } }  加减乘除 这题是一个模板题，考的是欧拉筛\n直接给出代码\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int N = 1E7 + 5; long long prime[N]; bool vis[N]; double oula(int n) { double ans = 0; int cot = 0; memset(vis, true, sizeof vis); for (int i = 2; i \u0026lt;= n; i++) { if (vis[i]) { prime[cot++] = i; switch (cot % 4) { case 1: ans += prime[cot - 1]; break; case 2: ans -= prime[cot - 1]; break; case 3: ans *= prime[cot - 1]; break; case 0: cot == 0 ? ans += prime[0] : ans /= prime[cot - 1]; break; default: break; } } for (int j = 0; j \u0026lt; cot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; j++) { vis[i * prime[j]] = false; if (i % prime[j] == 0) break; } } return ans; } int main() { int n; while (~scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)) { printf(\u0026quot;%.5lf\\n\u0026quot;, oula(n)); } }  A*B 和昨天的 A+B 差不多，模板题。\n直接给出代码\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int N = 100005; //取决于你的字符串的大小 void reverse(char s[]) { int len = strlen(s); for (int i = 0, j = len - 1; i \u0026lt; j; i++, j--) { char t = s[i]; s[i] = s[j]; s[j] = t; } } void mult(char s1[], char s2[], char ans[]) { int result[N] = {0}; int len1 = strlen(s1); int len2 = strlen(s2); reverse(s1); reverse(s2); for (int i = 0; i \u0026lt; len1; i++) { for (int j = 0; j \u0026lt; len2; j++) { result[i + j] += (s1[i] - '0') * (s2[j] - '0'); } } int i; for (i = 0; i \u0026lt; len1 + len2; i++) { result[i + 1] += result[i] / 10; result[i] %= 10; } i = len1 + len2 - 1; while (i \u0026gt; 0 \u0026amp;\u0026amp; result[i] == 0) i--; ans[i + 1] = '\\0'; for (; i \u0026gt;= 0; i--) ans[i] = result[i] + '0'; reverse(ans); } int main() { char s1[N], s2[N], ans[N]; while (scanf(\u0026quot;%s%s\u0026quot;, s1, s2) != EOF) { mult(s1, s2, ans); printf(\u0026quot;%s\\n\u0026quot;, ans); } }  C++代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string mult(string a, string b) { string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int len1 = a.length(), len2 = b.length(), result[len1 + len2] = {0}; for (int i = 0; i \u0026lt; len1; i++) for (int j = 0; j \u0026lt; len2; j++) result[i + j] += (a[i] - '0') * (b[j] - '0'); for (int i = 0; i \u0026lt; len1 + len2 - 1; i++) { result[i + 1] += result[i] / 10; result[i] %= 10; } int i = len1 + len2 - 1; while (result[i] == 0 \u0026amp;\u0026amp; i \u0026gt; 0) i--; for (; i \u0026gt;= 0; i--) ans += char(result[i] + '0'); return ans; } int main() { string a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; mult(a, b) \u0026lt;\u0026lt; endl; }  8421BCD 码 这是一个看表题没什么难度\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; char *s[10] = { \u0026quot;0000\u0026quot;, \u0026quot;1000\u0026quot;, \u0026quot;0100\u0026quot;, \u0026quot;1100\u0026quot;, \u0026quot;0010\u0026quot;, \u0026quot;1010\u0026quot;, \u0026quot;0110\u0026quot;, \u0026quot;1110\u0026quot;, \u0026quot;0001\u0026quot;, \u0026quot;1001\u0026quot;}; char ans[1000]; int main() { long long n; scanf(\u0026quot;%lld\u0026quot;, \u0026amp;n); while (n) { strcat(ans, s[n % 10]); n /= 10; } for (int i = strlen(ans) - 1; i \u0026gt;= 0; i--) printf(\u0026quot;%c\u0026quot;, ans[i]); }  C++代码\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s[10] = { \u0026quot;0000\u0026quot;, \u0026quot;0001\u0026quot;, \u0026quot;0010\u0026quot;, \u0026quot;0011\u0026quot;, \u0026quot;0100\u0026quot;, \u0026quot;0101\u0026quot;, \u0026quot;0110\u0026quot;, \u0026quot;0111\u0026quot;, \u0026quot;1000\u0026quot;, \u0026quot;1001\u0026quot;}; long long n; while (cin \u0026gt;\u0026gt; n) { string ss; while (n) { ss = s[n % 10] + ss; n /= 10; } cout \u0026lt;\u0026lt; ss \u0026lt;\u0026lt; endl; } }  跳方格 这题就是一般个找规律写出递归表达式，你就会发现规律：\n假设第一个数为 m\n   n (前 n+1 项和)F 前的项数 (前 n+1 项和)B 前的项数 第 n+1 项 前 n+1 项和 S     0 0 0 m m   1 1 0 m+F 2m+F   2 2 -1 m+F-B 3m+2F-B   3 4 -2 m+2F-B 4m+4F-2B   4 6 -4 m+2F-2B 5m+6F-4B   5 9 -6 m+3F-2B 6m+9F-6B   6 12 -9 m+3F-3B 7m+12F-9B   7 16 -12 m+4F-3B 8n+16F-12B   8 20 -16 m+4F-4B 9m+20F-16B   9 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip;    令 t=(前 n+1 项和)F 前的项数,令 tt= (前 n+1 项和)B 前的项数。\n很容易得出 t 和 tt 的递推公式。 所以这题就很简单了。\n列出等式\n$$(n+1)M+tF-ttB=S$$\n解得\n$$M=\\frac{S+ttB-tF}{n+1}$$\n所以给出代码。\nC 代码\n#include \u0026lt;stdio.h\u0026gt; int main() { long long n, s, f, b; while (~scanf(\u0026quot;%lld%lld%lld%lld\u0026quot;, \u0026amp;n, \u0026amp;s, \u0026amp;f, \u0026amp;b)) { long long t, tt; if (n \u0026amp; 1) t = ((n + 1) / 2) * ((n + 1) / 2), tt = (n - 1) / 2 * ((n - 1) / 2 + 1); else t = (n / 2) * (n / 2 + 1), tt = (n / 2) * (n / 2); printf(\u0026quot;%lld\\n\u0026quot;, (s + tt * b - t * f) / (n + 1)); } }  C++代码\n#include \u0026lt;iostream\u0026gt; using namespace std; using ll = long long; int main() { ll n, s, f, b; while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; f \u0026gt;\u0026gt; b) { ll t, tt; if (n \u0026amp; 1) t = ((n + 1) / 2) * ((n + 1) / 2), tt = (n - 1) / 2 * ((n - 1) / 2 + 1); else t = (n / 2) * (n / 2 + 1), tt = (n / 2) * (n / 2); cout \u0026lt;\u0026lt; (s + tt * b - t * f) / (n + 1) \u0026lt;\u0026lt; endl; } }  贾新远的旋转寿司 这题一开始我用 scanf(\u0026quot;%s\u0026quot;,s);但是不能过，后来想了想字符串可能有空格所以要用 gets 读才能读空格。C++ 用 cin.get 来读。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char s[105]; gets(s); for (int i = 0, j = strlen(s) - 1; i \u0026lt; j; i++, j--) if (s[i] != s[j]) { printf(\u0026quot;False\\n\u0026quot;); return 0; } printf(\u0026quot;True\u0026quot;); }  Kruskal 这是一道数据结构题，也是模板题。需要用到图论，Kruskal 和并查集的算法。\nC++代码\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; const int N = 1E5+7; int father[N]; int get_root(int x){ return x==father[x]?x:father[x]=get_root(father[x]); } void merge(int x,int y){ father[get_root(x)]=get_root(y); } void init(int father[],int n){ for(int i=1;i\u0026lt;=n;i++) father[i]=i; } struct Edge{ int u,v,w; bool operator\u0026lt; (const Edge W)const{ return w \u0026lt; W.w; } }; int Kruskal(int n,int m,vector\u0026lt;Edge\u0026gt;edge){ int res = 0; init(father,n); sort(edge.begin(),edge.end()); for(int i=0;i\u0026lt;m;i++){ int u=edge[i].u,v=edge[i].v; int father_u=get_root(u),father_v=get_root(v); if(father_u!=father_v){ res+=edge[i].w; merge(father_u,father_v); } } return res; } int main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;Edge\u0026gt;edge(m); for(auto \u0026amp;i:edge) cin\u0026gt;\u0026gt;i.u\u0026gt;\u0026gt;i.v\u0026gt;\u0026gt;i.w; cout\u0026lt;\u0026lt;Kruskal(n,m,edge)\u0026lt;\u0026lt;endl; }  许钟乐的头发数量 这题是一题解密题，以前的蓝桥杯题目\nszxyoj 上也有相似的题目可以看看。\n 阅读理解\n 首先将他转化出来\n转化 C 代码\n#include \u0026lt;stdio.h\u0026gt; int main() { // freopen(\u0026quot;1.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout); int a[20][6] = {0}; for (int i = 0; i \u0026lt; 20; i++) for (int j = 0; j \u0026lt; 6; j++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]); for (int i = 0; i \u0026lt; 20; i++) { for (int j = 0; j \u0026lt; 6; j++) { for (int k = 16; k \u0026gt;= 0; k--) if ((a[i][j] \u0026gt;\u0026gt; k) \u0026amp; 1) printf(\u0026quot;1\u0026quot;); else printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); } }  输出的图形是这样的\n111 111 1111 111 1 111 111 11 111 1111 111111 1 11 1111 11111 1111 111 111 11111 11111111 1 11 111111111 11111111 1111 11111111111 1111111 111 1111 111 11111 111111111 111 111 111 1 11111111111 1111111111111111 111 1111 1111 111 111 111 111111 111 111 1111 11 1111 1111 111 111 111 111 111 111 111111 111 111 111 111 111 111 1111 11111111 111 11111 111 1111 111 111 111 111 111 111111 111 111 111 111 11111 111 11111111111 1111 11111111 111 11111 111 111 1111 11 1 111 11111111111 111 1111 111 111 111 111 111 1111 11 1 1111 1111 111 111 111 111 111 111 111 11 111 111 1 11111 111 111 111 111 111 111 11 11 111 111 111 11111 111 111 1111 1111 111 111 111 111 111 111 111 111 1111 111 11111111 111 11111 111 11111111 1111 1111 1111 1111 111 111 111111 111 11111 111 1111 111 1111 11111 111 1111 111 111 111 111111 11 1 111 1111 1111 111111 1111 1 11 11 111 11111  其实就是 8 的三次方\n所以很简单，手算 8 的三次方\nC 代码\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026quot;%d\\n\u0026quot;,8*8*8-64); } ","date":"2019-12-15","permalink":"https://52funny.github.io/posts/005/","tags":["算法"],"title":"IT创新实验室19级阶段性测试二"},{"content":" 19 阶段性测试\n 这次测试题题目中规中矩，不是很难也不是很简单。在这里给出一些题解，有的我也不一定会，毕竟实验室大佬很多。\n熊文静的抖音密码 这题很简单，简单的模拟题直接给出代码\nC 代码\n#include \u0026lt;stdio.h\u0026gt; int main() { char s[100]; int n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); getchar(); gets(s); for (int i = 0; s[i] != '\\0'; i++) s[i] = (s[i] - 'a' + n) % 26 + 'a'; puts(s); }  许钟乐的诛心算比赛 这题就是一个暴力搜，数据范围很小，我的做法是先把 a 数组所有的能加的情况加起来放到另一个数组 b，然后 a 数组与 b 数组里的数一一比较。\n下面给出代码\nC 代码\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int a[105], b[10005], cot = 0; for (int i = 0; i \u0026lt; n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); for (int i = 0; i \u0026lt; n - 1; i++) for (int j = i + 1; j \u0026lt; n; j++) b[cot++] = a[i] + a[j]; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; cot; j++) if (a[i] == b[j]) { ans++; break; } } printf(\u0026quot;%d\u0026quot;, ans); return 0; }  C++代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; v; int main() { int n, a[1000]; cin \u0026gt;\u0026gt; n; int cot = 0; vector\u0026lt;int\u0026gt; v(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt; n - 1; i++) for (int j = i + 1; j \u0026lt; n; j++) v.push_back(a[i] + a[j]); for (int i = 0; i \u0026lt; n; i++) for (auto j : v) if (a[i] == j) { cot++; break; } cout \u0026lt;\u0026lt; cot \u0026lt;\u0026lt; endl; }  函数方程 这题由于数据过小，直接暴力搜，当数据大了的话，可以用二分。\n由于这题数据比较小。所以直接暴力搜。\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #define INF 1E-6 int check(double x) { if (x * x * x * x * x - 15 * x * x * x * x + 85 * x * x * x - 225 * x * x + 274 * x - 121 \u0026lt; INF) return 1; return 0; } int main() { for (double i = 1.5; i \u0026lt;= 2.4; i += 0.00001) if (check(i)) { printf(\u0026quot;%.5lf\u0026quot;, i); break; } }  或者这题直接写答案就可以\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026quot;1.84902\u0026quot;); }  A+B 这题一看就不能用long long因为long long的范围就是$-2^{63}$ ~ $2^{63}-1$化简一下就是-9223372036854775808 ~ 9223372036854775807 所以这个范围肯定超了long long，所以我们要用字符串模拟。\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int N = 10005; void reverse(char s[]) { int len = strlen(s); for (int i = 0, j = len - 1; i \u0026lt; j; i++, j--) { char t = s[i]; s[i] = s[j]; s[j] = t; } } void add(char s1[], char s2[], char ans[]) { int len1 = strlen(s1); int len2 = strlen(s2); reverse(s1); reverse(s2); int hex = 0, i; int len = len1 \u0026gt; len2 ? len1 : len2; for (i = 0; i \u0026lt; len; i++) { int a = 0; int b = 0; if (i \u0026lt; len1) a = s1[i] - '0'; if (i \u0026lt; len2) b = s2[i] - '0'; ans[i] = (a + b + hex) % 10 + '0'; hex = (a + b + hex) / 10; } if (hex) ans[i++] = hex + '0'; ans[i] = '\\0'; reverse(ans); } int main() { char s1[N], s2[N], ans[N]; scanf(\u0026quot;%s%s\u0026quot;, s1, s2); add(s1, s2, ans); printf(\u0026quot;%s\\n\u0026quot;, ans); }  C++ 代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string add(string a, string b) { int hex = 0; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int len1 = a.length(); int len2 = b.length(); string ans; for (int i = 0, j = 0; i \u0026lt; len1 || j \u0026lt; len2; i++, j++) { int num1 = 0, num2 = 0; if (i \u0026lt; len1) num1 = a[i] - '0'; if (j \u0026lt; len2) num2 = b[i] - '0'; ans = char((num1 + num2 + hex) % 10 + '0') + ans; hex = (num1 + num2 + hex) / 10; } if (hex) ans = char(hex + '0') + ans; return ans; } int main() { string a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; endl; }  这种高精度算法是很常见的算法，希望大家一定牢记在心。\n解密数字 这题是一题找规律题，给了一个表格可以得出来很简单的规律，首先进行 n 的转换$n\\rightarrow n+1$，然后将$n+1$转成二进制然后除去最高位进制。\n下面直接给代码\nC 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int N = 10005; int ans[N]; int main() { int n; while (~scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)) { int cot = 0; ++n; while (n) { ans[cot++] = (n % 2); n \u0026gt;\u0026gt;= 1; } for (int i = cot - 2; i \u0026gt;= 0; i--) printf(\u0026quot;%d\u0026quot;, ans[i]); printf(\u0026quot;\\n\u0026quot;); } }  C++ 代码\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int s; while (cin \u0026gt;\u0026gt; s) { ++s; string ans; while (s) { ans = (s \u0026amp; 1 ? '1' : '0') + ans; s \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; ans.substr(1) \u0026lt;\u0026lt; '\\n'; } }  后缀表达式 这题是数据结构上的东西，要用到栈，想学的就去查一下。\n我直接上 C++代码\nC++代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; using ll = long long; string RPN(string s) { stack\u0026lt;char\u0026gt; st; string ans; for (int j = 0; j \u0026lt; s.size(); j++) { char i = s[j]; if (isdigit(i) || isalpha(i)) { while (isdigit(s[j])) { ans += s[j]; j++; } ans += '#'; j--; continue; } if (i == '(') st.push('('); else if (i == ')') { while (!st.empty() \u0026amp;\u0026amp; st.top() != '(') { ans += st.top(); st.pop(); } st.pop(); } else if (i == '+' || i == '-') { while (!st.empty() \u0026amp;\u0026amp; st.top() != '(') { ans += st.top(); st.pop(); } st.push(i); } else if (i == '*' || i == '/') { while (!st.empty()) { if (st.top() == '*' || st.top() == '/') { ans += st.top(); st.pop(); } else break; } st.push(i); } } while (!st.empty()) { ans += st.top(); st.pop(); } return ans; } double slove(string s) { ll a = 0; stack\u0026lt;double\u0026gt; st; for (auto i : s) { if (isdigit(i)) { a = a * 10 + (i - '0'); } else if (i == '#') { st.push(a); a = 0; } else { if (i == '+') { double a = st.top(); st.pop(); double b = st.top(); st.pop(); st.push(a + b); } if (i == '-') { double a = st.top(); st.pop(); double b = st.top(); st.pop(); st.push(b - a); } if (i == '*') { double a = st.top(); st.pop(); double b = st.top(); st.pop(); st.push(a * b); } if (i == '/') { double a = st.top(); st.pop(); double b = st.top(); st.pop(); st.push(b * 1.0 / a); } } } return st.top(); } int main() { string s; while (cin \u0026gt;\u0026gt; s) { printf(\u0026quot;%.4lf\\n\u0026quot;, slove(RPN(s))); } }  小文的烤鸡 这题是实验室的贾佬憨出的，虽然看了像在骂我，但是我不介意。这题直接暴力搜就好，没什么问题。\nC 语言\n#include \u0026lt;stdio.h\u0026gt; int main() { int t[5005][10]; int a, b, c, d, e, f, g, h, i, j, n,ans=0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (a = 1; a \u0026lt;= 3; a++) for (b = 1; b \u0026lt;= 3; b++) for (c = 1; c \u0026lt;= 3; c++) for (d = 1; d \u0026lt;= 3; d++) for (e = 1; e \u0026lt;= 3; e++) for (f = 1; f \u0026lt;= 3; f++) for (g = 1; g \u0026lt;= 3; g++) for (h = 1; h \u0026lt;= 3; h++) for (i = 1; i \u0026lt;= 3; i++) for (j = 1; j \u0026lt;= 3; j++) if(a + b + c + d + e + f + g + h + i + j == n){ t[ans][0]=a; t[ans][1]=b; t[ans][2]=c; t[ans][3]=d; t[ans][4]=e; t[ans][5]=f; t[ans][6]=g; t[ans][7]=h; t[ans][8]=i; t[ans][9]=j; ans++; } printf(\u0026quot;%d\\n\u0026quot;, ans); if(ans == 0) printf(\u0026quot;%d\u0026quot;, 0); else for(int i=0; i \u0026lt; ans; i++) printf(\u0026quot;%d %d %d %d %d %d %d %d %d %d\\n\u0026quot;, t[i][0], t[i][1], t[i][2], t[i][3], t[i][4], t[i][5], t[i][6], t[i][7], t[i][8], t[i][9]); }  吐了，写了这么多循环。\n探险日志 大佬的题真的强，我不会，我哭辽。明天找叶大佬交易一波，让他教我怎么写，我在把这题补全。\n今天找大佬交易了一波，叶大佬把代码传授于我。我转发到了这。 这题是一题 BFS(广度优先搜索)\n首先将地图中的所有门及所对应的钥匙用一个数组存储数量，用于判断在搜索过程中当前拥有的钥匙是否满足打开某个门的条件。BFS 从起点开始搜索，在搜索过程中用一个 bool 型变量标记在此次搜索中是否寻找到了新钥匙。搜索中，可能遇到门后由于该门所对应的钥匙不足而打不开，所以一旦找到了新钥匙，就重新从起点开始再次搜索判断之前未打开的门是否能够新获得的钥匙打开。然后，每次打开心得门可能又会获得新的钥匙，所以除非找不到新钥匙，BFS 每次都从起点重新搜索，最后结束之后，判断是否找到终点就可以了。\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; char road[22][22];\t//存储迷宫 bool book[22][22], flag,k;\t//book用来标记寻找终点时的路径标记 int Next[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; //四个方向 int M, N, x1, Y1, x2, y2;\t//M行，N列，起始点坐标和终点坐标 int key[5], allkey[5];\t//已找到的钥匙数和钥匙总数 struct node { int x, y; //广搜所用结构体，存储当前点的坐标 } door[5]; queue\u0026lt;node\u0026gt; q; void bfs(node temp) { book[x1][Y1] = book[x2][y2] = true; //起点和终点标记为已走过 while (!q.empty()) { //如果队列不为空，清空队列 q.pop(); } q.push(temp); //将起点入队 while (!q.empty()) { //队列不为空时循环 for (int i = 0; i \u0026lt; 4; ++i) { //枚举四个方向 int nextx = q.front().x + Next[i][0]; int nexty = q.front().y + Next[i][1]; if (nextx \u0026lt; 0 || nexty \u0026lt; 0 || nextx \u0026gt;= M || nexty \u0026gt;= N) { //越界则尝试下一个方向 continue; } if (road[nextx][nexty] \u0026gt;= 97) {\t//如果下一个位置是钥匙 key[road[nextx][nexty] - 97]++; //已找到的钥匙数加一 k = true; if (key[road[nextx][nexty] - 97] == allkey[road[nextx][nexty] - 97]) { road[door[road[nextx][nexty] - 97].x][door[road[nextx][nexty] - 97].y] = '.'; } road[nextx][nexty] = '.'; //将该钥匙点变为可走的路 } if (!book[nextx][nexty] \u0026amp;\u0026amp; (road[nextx][nexty] \u0026lt; 65 || road[nextx][nexty] \u0026gt; 90)) {\t//如果该点没走过且能走 book[nextx][nexty] = true; //将该点标记为已走过 node t = {nextx, nexty}; q.push(t); //将该点入队 } if (nextx == x2 \u0026amp;\u0026amp; nexty == y2) { flag = true; return; } } q.pop(); //将队首出队 } memset(book, false, sizeof(book)); //清空路径标记 } int main() { //freopen(\u0026quot;1.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); //freopen(\u0026quot;1.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); while (cin \u0026gt;\u0026gt; M \u0026amp;\u0026amp; cin \u0026gt;\u0026gt; N) { //循环输入M,N if (M == 0 \u0026amp;\u0026amp; N == 0) { //全为零时退出 break; } flag = false; k = false; memset(road, '\\0', sizeof(road)); //每次清空路径数组 memset(book, false, sizeof(book)); //清空路径标记 memset(key, 0, sizeof(key));\t//清空已找到钥匙标记 memset(allkey, 0, sizeof(allkey)); //清空全部钥匙标记 for (int i = 0; i \u0026lt; M; ++i) { //双重循环输入 for (int j = 0; j \u0026lt; N; ++j) { cin \u0026gt;\u0026gt; road[i][j]; if (road[i][j] \u0026gt;= 97) {\t//如果输入的是钥匙 allkey[road[i][j] - 97]++; //该种钥匙总数加一 } else if (road[i][j] == 'S') {\t//如果输入了起点 x1 = i; //将起始点存储 Y1 = j; } else if (road[i][j] == 'G') {\t//如果输入了终点 x2 = i; //将终点存储 y2 = j; } else if (road[i][j] \u0026gt;= 65 \u0026amp;\u0026amp; road[i][j] \u0026lt;= 69) { door[road[i][j] - 65].x = i; door[road[i][j] - 65].y = j; } } } node temp = {x1, Y1}; //根据起点坐标创建结构体变量 bfs(temp); while(k) { //如果此次搜索到了新钥匙，就再次搜索能否通过这个钥匙打开新的门 k = false; bfs(temp); } book[x1][Y1] = true; //起点标记为已走过 if (flag) { cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; } } return 0; } ","date":"2019-12-14","permalink":"https://52funny.github.io/posts/004/","tags":["算法"],"title":"IT创新实验室19级阶段性测试一"},{"content":"大家都有过高精度类型的经历，比如让你算 A+B 的答案，正常人肯定就是认为就直接 A+B 了，但是如果 A,B 的范围都超过了 long long 的范围。那么 C++肯定是用long long算不出来的，所以我们要进行字符串的模拟\nA+B $(A,B\u0026gt;=0)$ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string add(string a, string b) { int hex = 0; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int len1 = a.length(); int len2 = b.length(); string ans; for (int i = 0, j = 0; i \u0026lt; len1 || j \u0026lt; len2; i++, j++) { int num1 = 0, num2 = 0; if (i \u0026lt; len1) num1 = a[i] - '0'; if (j \u0026lt; len2) num2 = b[i] - '0'; ans = char((num1 + num2 + hex) % 10 + '0') + ans; hex = (num1 + num2 + hex) / 10; } if (hex) ans = char(hex + '0') + ans; return ans; } int main() { string a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; endl; }  A*B $(A,B\u0026gt;=0)$ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string mult(string a, string b) { string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int len1 = a.length(), len2 = b.length(), result[len1 + len2] = {0}; for (int i = 0; i \u0026lt; len1; i++) for (int j = 0; j \u0026lt; len2; j++) result[i + j] += (a[i] - '0') * (b[j] - '0'); for (int i = 0; i \u0026lt; len1 + len2 - 1; i++) { result[i + 1] += result[i] / 10; result[i] %= 10; } int i = len1 + len2 - 1; while (result[i] == 0 \u0026amp;\u0026amp; i \u0026gt; 0) i--; for (; i \u0026gt;= 0; i--) ans += char(result[i] + '0'); return ans; } int main() { string a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; mult(a, b) \u0026lt;\u0026lt; endl; }  A-B $(A,B\u0026gt;=0)$ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string sub(string a, string b) { int len1 = a.length(), len2 = b.length(), result[max(len1, len2)]{0}; //假设a是最大的，b是最小的 bool flag = false; string ans; if (len1 \u0026lt; len2) swap(a, b), swap(len1, len2), flag = true; else if (len1 == len2) { int i; for (i = 0; i \u0026lt; len1 \u0026amp;\u0026amp; a[i] == b[i]; i++); if (a[i] \u0026lt; b[i]) swap(a, b), flag = true; } reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int i; for (i = 0; i \u0026lt; len2; i++) if (a[i] \u0026gt;= b[i]) result[i] = a[i] - b[i]; else result[i] = a[i] + 10 - b[i], a[i + 1] -= 1; while (i \u0026lt; len1) result[i] = a[i] - '0', i++; for (i = len1 - 1; i \u0026gt; 0; i--) if (result[i] == 0) len1--; else break; for (i = 0; i \u0026lt; len1; i++) ans = char(result[i] + '0') + ans; if (flag) ans = \u0026quot;-\u0026quot; + ans; return ans; } int main() { string a, b; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; sub(a, b) \u0026lt;\u0026lt; endl; }  如果整合有需要，我贴一个链接\nC++整合代码\nC 整合代码\n","date":"2019-12-06","permalink":"https://52funny.github.io/posts/003/","tags":["算法"],"title":"高精度算法"},{"content":" 多喝嘤料\n来源：牛客网\n 题目描述 卖嘤料 卖嘤料~~\n3 个空瓶换一瓶。\n4 个瓶盖换一瓶。\n问已购买 n 瓶嘤料的 QAQ 能喝到多少瓶嘤料？\n输入描述  第一行一个正整数 T(0\u0026lt;T\u0026lt;=100)\n随后 T 行，每行一个整数 n(0\u0026lt;=n\u0026lt;=1000000)\n 输出描述  第一行一个正整数 T(0\u0026lt;T\u0026lt;=100)\n随后 T 行，每行一个整数 n(0\u0026lt;=n\u0026lt;=1000000)\n 示例 1 输入 3 1 2 10  输出 1 2 22  题解 这里我们用 Java 语言来示范一下(Ps:我最近在学 Java，所以用 Java 来小试牛刀)\n下面直接给出代码\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int T=sc.nextInt(); while(T--!=0) { int n=sc.nextInt(); long ans=0L; long pg=n; long kp=n; ans+=n; while(kp\u0026gt;=3||pg\u0026gt;=4) { long res=kp/3+pg/4; kp=res+kp%3; pg=res+pg%4; ans+=res; } System.out.println(ans); } } }  补充一下 C++的代码\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ int n; cin\u0026gt;\u0026gt;n; long long ans=n,kp=n,pg=n; while(kp\u0026gt;=3||pg\u0026gt;=3){ long long res=kp/3+pg/4; kp=res+kp%3; pg=res+pg%4; ans+=res; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"2019-12-03","permalink":"https://52funny.github.io/posts/002/","tags":["算法"],"title":"多喝嘤料"},{"content":" 回文串\n来源：牛客网\n 题目描述 既然大家都知道回文串是怎么回事了，那我们就长话短说，现在有一个字符串，长度小于 1200，我想知道最长的回文子串长度是多少。\n输入描述  多组输入，输入字符串只包含小写字母。\n 输出描述  每组输出一个数字，表示最长的回文子串。\n 示例 1 输入 aqppqole ebcml  输出 4 1  题解 这题的数据量不是很大 首先我们可以把所有的子串暴力找出来看他是否是回文子串，并把回文子串的长度加入到 vector 数组里面去，最后遍历出最长的长度。 这里给出代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int check(string s) { int len = s.length(); for (int i = 0, j = len - 1; i \u0026lt;= j; i++, j--) { if (s[i] != s[j]) return false; } return true; } vector\u0026lt;int\u0026gt; v; int main() { //freopen(\u0026quot;1.in\u0026quot;, \u0026quot;r\u0026quot;, stdin); string s; while (cin \u0026gt;\u0026gt; s) { //double t1 = clock(); int len = s.length(); for (int i = 0; i \u0026lt; len; i++) { for (int j = 1; j \u0026lt;= len - i; j++) if (check(s.substr(i, j))) v.push_back(s.substr(i, j).length()); } cout \u0026lt;\u0026lt; *max_element(v.begin(), v.end()) \u0026lt;\u0026lt; endl; v.clear(); //double t2 = clock(); //cout \u0026lt;\u0026lt; (t2 - t1) / 1000 \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-12-03","permalink":"https://52funny.github.io/posts/001/","tags":["算法"],"title":"回文串"}]