<!doctype html><html lang=zh-hans><meta charset=utf-8><meta name=generator content="Hugo 0.119.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>LRU Cache 算法&nbsp;&ndash;&nbsp;52funny Blog</title><link rel=stylesheet href=/css/core.min.f9b23fe57ee1e0c49df056e1568197ac8020cde0cf8113c1b532070854073b8f05cef8631555e6d24c3ad2c550a48deb.css integrity=sha384-+bI/5X7h4MSd8FbhVoGXrIAgzeDPgRPBtTIHCFQHO48FzvhjFVXm0kw60sVQpI3r><meta name=twitter:card content="summary"><meta name=twitter:title content="LRU Cache 算法"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">52funny Blog</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/></a><a class="nav item" href=/tags/></a><a class="nav item" href=/>Home</a><a class="nav item" href=/algorithm>Algorithm</a><a class="nav item" href=/friends>Friends</a><a class="nav item" href=/about>About</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">LRU Cache 算法</h1><p class="article date">2024-04-08</p></section><article class="article markdown-body"><p>LRU 是缓存替换机制中的一个算法。由于计算机存储空间大小是 <strong>固定</strong> 的，并不是无限大小的空间，无法容纳所有的数据，所以当有新的数据要被置换到 <strong>缓存</strong> 时，必须采用一定的原则来取代适当的数据。此原则就是 <strong>缓存淘汰算法</strong>。</p><h2 id=缓存淘汰算法>缓存淘汰算法</h2><p>传统的淘汰算法有以下算法：</p><ul><li>先进先出算法（FIFO）：最先进入的内容作为替换对象</li><li>最少使用算法（LFU）：最久没有访问的内容作为替换对象</li><li>最近最少使用算法（LRU）：最近最少使用的内容作为替换对象</li><li>非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象</li></ul><p><strong>LRU</strong>（Least recently used） 算法根据内容的历史访问次数来进行淘汰数据，其核心思想是「如果一个内容最近被访问过，那么将来被访问的几率也会很高。」</p><p>我们可以使用双端链表来进行模拟数据，然后根据内容数据的访问来删除一些数据。</p><ol><li>当有新的内容数据要 <strong>插入</strong> 或者 <strong>更新</strong> 的时候，我们将其插入到链表头部</li><li>当每次内容被 <strong>命中</strong> 的时候，则将内容移动到链表头部</li><li>当 <strong>链表满</strong> 的时候，将链表尾部的内容进行丢弃</li></ol><p><a href=https://leetcode.cn/problems/lru-cache/ target=_blank rel="noopener noreferrer">146.LRU 缓存</a>
让我们实现一个 LRU 的模拟。我们可以使用双向链表来实现 <strong>快速插入</strong> 节点到头部和 <strong>快速删除</strong> 尾部节点。同时我们要要实现将链表中间的元素 <strong>快速插入</strong> 到头部，所以我们要记住每一个中间节点的指针，我们可以使用 Hash 表来记住每一个节点的指针，这样我们就可以快速找到每一个指针的地址了。</p><p>代码实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstddef&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iterator&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> key;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>prev;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node() <span style=color:#f92672>:</span> key(<span style=color:#ae81ff>0</span>), val(<span style=color:#ae81ff>0</span>), prev(<span style=color:#66d9ef>nullptr</span>), next(<span style=color:#66d9ef>nullptr</span>) {}
</span></span><span style=display:flex><span>    Node(<span style=color:#66d9ef>int</span> key, <span style=color:#66d9ef>int</span> val) <span style=color:#f92672>:</span> key(key), val(val), prev(<span style=color:#66d9ef>nullptr</span>), next(<span style=color:#66d9ef>nullptr</span>) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LRUCache</span> {
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>head;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>tail;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, Node <span style=color:#f92672>*&gt;</span> h;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> capacity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> now;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pushHead</span>(Node <span style=color:#f92672>*</span>n) {
</span></span><span style=display:flex><span>        Node <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        n<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        n<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(Node <span style=color:#f92672>*</span>n) {
</span></span><span style=display:flex><span>        Node <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> n<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>        Node <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> n<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    LRUCache(<span style=color:#66d9ef>int</span> capacity) <span style=color:#f92672>:</span> capacity(capacity) {
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node();
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node();
</span></span><span style=display:flex><span>        head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        tail<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        now <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (h.count(key) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        remove(h[key]);
</span></span><span style=display:flex><span>        pushHead(h[key]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> h[key]<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(<span style=color:#66d9ef>int</span> key, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (h.count(key) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            h[key]<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>            remove(h[key]);
</span></span><span style=display:flex><span>            pushHead(h[key]);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (now <span style=color:#f92672>&gt;=</span> capacity) {
</span></span><span style=display:flex><span>            Node <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> tail<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>            remove(last);
</span></span><span style=display:flex><span>            h.erase(last<span style=color:#f92672>-&gt;</span>key);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> last;
</span></span><span style=display:flex><span>            now<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(key, val);
</span></span><span style=display:flex><span>        pushHead(n);
</span></span><span style=display:flex><span>        now<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        h[key] <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=参考内容>参考内容</h1><p><a href=https://en.wikipedia.org/wiki/Cache_replacement_policies target=_blank rel="noopener noreferrer">https://en.wikipedia.org/wiki/Cache_replacement_policies</a></p><p><a href=https://zhuanlan.zhihu.com/p/34989978 target=_blank rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/34989978</a></p></article><section class="article labels"><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/%E6%8E%A5%E9%9B%A8%E6%B0%B4/><span class="iconfont icon-article"></span>接雨水</a></p><p><a class=link href=/posts/permutation/><span class="iconfont icon-article"></span>全排序算法</a></p></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>52funny Blog</p><p class=powerby><span>Powered&nbsp;by&nbsp;</span><a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a><span>&nbsp;&&nbsp;</span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank rel="noopener noreferrer">Notepadium</a></p></div></section><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script>
<script type=text/x-mathjax-config>MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script><script src=/js/hljs.min.6f979583f61e4ec5f0b94f94eab2e130ee628032474d374414dba4e33cc12097a0d01fe65b33378b23f6d3b053b95445.js integrity=sha384-b5eVg/YeTsXwuU+U6rLhMO5igDJHTTdEFNuk4zzBIJeg0B/mWzM3iyP207BTuVRF></script><script>hljs.initHighlightingOnLoad()</script></body></html>